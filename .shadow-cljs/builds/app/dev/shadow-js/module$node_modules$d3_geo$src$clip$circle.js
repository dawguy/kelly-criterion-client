["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/d3-geo/src/clip/circle.js"],"~:js","shadow$provide.module$node_modules$d3_geo$src$clip$circle=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=function(radius){function visible(lambda,phi){return(0,_math.cos)(lambda)*(0,_math.cos)(phi)>cr}function intersect(a,b,two){var pa=(0,_cartesian.cartesian)(a),pb=(0,_cartesian.cartesian)(b),n1=[1,0,0];pb=(0,_cartesian.cartesianCross)(pa,pb);var n2n2=\n(0,_cartesian.cartesianDot)(pb,pb);pa=pb[0];var determinant=n2n2-pa*pa;if(!determinant)return!two&&a;n2n2=cr*n2n2/determinant;determinant=-cr*pa/determinant;pa=(0,_cartesian.cartesianCross)(n1,pb);n1=(0,_cartesian.cartesianScale)(n1,n2n2);pb=(0,_cartesian.cartesianScale)(pb,determinant);(0,_cartesian.cartesianAddInPlace)(n1,pb);pb=(0,_cartesian.cartesianDot)(n1,pa);n2n2=(0,_cartesian.cartesianDot)(pa,pa);determinant=pb*pb-n2n2*((0,_cartesian.cartesianDot)(n1,n1)-1);if(!(0>determinant)){var t=(0,_math.sqrt)(determinant);\ndeterminant=(0,_cartesian.cartesianScale)(pa,(-pb-t)/n2n2);(0,_cartesian.cartesianAddInPlace)(determinant,n1);determinant=(0,_cartesian.spherical)(determinant);if(!two)return determinant;two=a[0];var lambda1=b[0];a=a[1];b=b[1];if(lambda1<two){var z=two;two=lambda1;lambda1=z}var delta=lambda1-two,polar=(0,_math.abs)(delta-_math.pi)<_math.epsilon,meridian=polar||delta<_math.epsilon;!polar&&b<a&&(z=a,a=b,b=z);if(meridian?polar?0<a+b^determinant[1]<((0,_math.abs)(determinant[0]-two)<_math.epsilon?a:b):\na<=determinant[1]&&determinant[1]<=b:delta>_math.pi^(two<=determinant[0]&&determinant[0]<=lambda1))return b=(0,_cartesian.cartesianScale)(pa,(-pb+t)/n2n2),(0,_cartesian.cartesianAddInPlace)(b,n1),[determinant,(0,_cartesian.spherical)(b)]}}function code$jscomp$0(lambda,phi){var r=smallRadius?radius:_math.pi-radius,code=0;lambda<-r?code|=1:lambda>r&&(code|=2);phi<-r?code|=4:phi>r&&(code|=8);return code}var cr=(0,_math.cos)(radius),delta$jscomp$0=6*_math.radians,smallRadius=0<cr,notHemisphere=(0,_math.abs)(cr)>\n_math.epsilon;return(0,_index.default)(visible,function(stream){var point0,c0,v0,v00,clean;return{lineStart:function(){v00=v0=!1;clean=1},point:function(lambda,phi){var point1=[lambda,phi],v=visible(lambda,phi);phi=smallRadius?v?0:code$jscomp$0(lambda,phi):v?code$jscomp$0(lambda+(0>lambda?_math.pi:-_math.pi),phi):0;!point0&&(v00=v0=v)&&stream.lineStart();v!==v0&&(lambda=intersect(point0,point1),!lambda||(0,_pointEqual.default)(point0,lambda)||(0,_pointEqual.default)(point1,lambda))&&(point1[2]=1);\nif(v!==v0)clean=0,v?(stream.lineStart(),lambda=intersect(point1,point0),stream.point(lambda[0],lambda[1])):(lambda=intersect(point0,point1),stream.point(lambda[0],lambda[1],2),stream.lineEnd()),point0=lambda;else if(notHemisphere&&point0&&smallRadius^v){var t;phi&c0||!(t=intersect(point1,point0,!0))||(clean=0,smallRadius?(stream.lineStart(),stream.point(t[0][0],t[0][1]),stream.point(t[1][0],t[1][1]),stream.lineEnd()):(stream.point(t[1][0],t[1][1]),stream.lineEnd(),stream.lineStart(),stream.point(t[0][0],\nt[0][1],3)))}!v||point0&&(0,_pointEqual.default)(point0,point1)||stream.point(point1[0],point1[1]);point0=point1;v0=v;c0=phi},lineEnd:function(){v0&&stream.lineEnd();point0=null},clean:function(){return clean|(v00&&v0)<<1}}},function(from,to,direction,stream){(0,_circle.circleStream)(stream,radius,delta$jscomp$0,direction,from,to)},smallRadius?[0,-radius]:[-_math.pi,radius-_math.pi])};var _cartesian=require(\"module$node_modules$d3_geo$src$cartesian\"),_circle=require(\"module$node_modules$d3_geo$src$circle\"),\n_math=require(\"module$node_modules$d3_geo$src$math\"),_pointEqual=_interopRequireDefault(require(\"module$node_modules$d3_geo$src$pointEqual\")),_index=_interopRequireDefault(require(\"module$node_modules$d3_geo$src$clip$index\"))}","~:source","shadow$provide[\"module$node_modules$d3_geo$src$clip$circle\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _cartesian = require(\"../cartesian.js\");\n\nvar _circle = require(\"../circle.js\");\n\nvar _math = require(\"../math.js\");\n\nvar _pointEqual = _interopRequireDefault(require(\"../pointEqual.js\"));\n\nvar _index = _interopRequireDefault(require(\"./index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _default(radius) {\n  var cr = (0, _math.cos)(radius),\n      delta = 6 * _math.radians,\n      smallRadius = cr > 0,\n      notHemisphere = (0, _math.abs)(cr) > _math.epsilon; // TODO optimise for this common case\n\n\n  function interpolate(from, to, direction, stream) {\n    (0, _circle.circleStream)(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr;\n  } // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n\n\n  function clipLine(stream) {\n    var point0, // previous point\n    c0, // code for previous point\n    v0, // visibility of previous point\n    v00, // visibility of first point\n    clean; // no intersections\n\n    return {\n      lineStart: function () {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function (lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || (0, _pointEqual.default)(point0, point2) || (0, _pointEqual.default)(point1, point2)) point1[2] = 1;\n        }\n\n        if (v !== v0) {\n          clean = 0;\n\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1], 2);\n            stream.lineEnd();\n          }\n\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t; // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n\n        if (v && (!point0 || !(0, _pointEqual.default)(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function () {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function () {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  } // Intersects the great circle between a and b with the clip circle.\n\n\n  function intersect(a, b, two) {\n    var pa = (0, _cartesian.cartesian)(a),\n        pb = (0, _cartesian.cartesian)(b); // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n\n    var n1 = [1, 0, 0],\n        // normal\n    n2 = (0, _cartesian.cartesianCross)(pa, pb),\n        n2n2 = (0, _cartesian.cartesianDot)(n2, n2),\n        n1n2 = n2[0],\n        // cartesianDot(n1, n2),\n    determinant = n2n2 - n1n2 * n1n2; // Two polar points.\n\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),\n        A = (0, _cartesian.cartesianScale)(n1, c1),\n        B = (0, _cartesian.cartesianScale)(n2, c2);\n    (0, _cartesian.cartesianAddInPlace)(A, B); // Solve |p(t)|^2 = 1.\n\n    var u = n1xn2,\n        w = (0, _cartesian.cartesianDot)(A, u),\n        uu = (0, _cartesian.cartesianDot)(u, u),\n        t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1);\n    if (t2 < 0) return;\n    var t = (0, _math.sqrt)(t2),\n        q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);\n    (0, _cartesian.cartesianAddInPlace)(q, A);\n    q = (0, _cartesian.spherical)(q);\n    if (!two) return q; // Two intersection points.\n\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,\n        meridian = polar || delta < _math.epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.\n\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);\n      (0, _cartesian.cartesianAddInPlace)(q1, A);\n      return [q, (0, _cartesian.spherical)(q1)];\n    }\n  } // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n\n\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : _math.pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n\n    return code;\n  }\n\n  return (0, _index.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi]);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$d3_geo$src$math","~$shadow.js","~$module$node_modules$d3_geo$src$cartesian","~$module$node_modules$d3_geo$src$clip$index","~$module$node_modules$d3_geo$src$circle","~$module$node_modules$d3_geo$src$pointEqual"]],"~:properties",["^5",["__esModule","value","lineEnd","lineStart","clean","default","point"]],"~:compiled-at",1653857611306,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$d3_geo$src$clip$circle.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/d3-geo/src/clip/circle.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$d3_geo$src$clip$circle\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = _default;\\n\\nvar _cartesian = require(\\\"../cartesian.js\\\");\\n\\nvar _circle = require(\\\"../circle.js\\\");\\n\\nvar _math = require(\\\"../math.js\\\");\\n\\nvar _pointEqual = _interopRequireDefault(require(\\\"../pointEqual.js\\\"));\\n\\nvar _index = _interopRequireDefault(require(\\\"./index.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _default(radius) {\\n  var cr = (0, _math.cos)(radius),\\n      delta = 6 * _math.radians,\\n      smallRadius = cr > 0,\\n      notHemisphere = (0, _math.abs)(cr) > _math.epsilon; // TODO optimise for this common case\\n\\n\\n  function interpolate(from, to, direction, stream) {\\n    (0, _circle.circleStream)(stream, radius, delta, direction, from, to);\\n  }\\n\\n  function visible(lambda, phi) {\\n    return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr;\\n  } // Takes a line and cuts into visible segments. Return values used for polygon\\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\\n  // intersections 2 - there were intersections, and the first and last segments\\n  // should be rejoined.\\n\\n\\n  function clipLine(stream) {\\n    var point0, // previous point\\n    c0, // code for previous point\\n    v0, // visibility of previous point\\n    v00, // visibility of first point\\n    clean; // no intersections\\n\\n    return {\\n      lineStart: function () {\\n        v00 = v0 = false;\\n        clean = 1;\\n      },\\n      point: function (lambda, phi) {\\n        var point1 = [lambda, phi],\\n            point2,\\n            v = visible(lambda, phi),\\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0;\\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\\n\\n        if (v !== v0) {\\n          point2 = intersect(point0, point1);\\n          if (!point2 || (0, _pointEqual.default)(point0, point2) || (0, _pointEqual.default)(point1, point2)) point1[2] = 1;\\n        }\\n\\n        if (v !== v0) {\\n          clean = 0;\\n\\n          if (v) {\\n            // outside going in\\n            stream.lineStart();\\n            point2 = intersect(point1, point0);\\n            stream.point(point2[0], point2[1]);\\n          } else {\\n            // inside going out\\n            point2 = intersect(point0, point1);\\n            stream.point(point2[0], point2[1], 2);\\n            stream.lineEnd();\\n          }\\n\\n          point0 = point2;\\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\\n          var t; // If the codes for two points are different, or are both zero,\\n          // and there this segment intersects with the small circle.\\n\\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\\n            clean = 0;\\n\\n            if (smallRadius) {\\n              stream.lineStart();\\n              stream.point(t[0][0], t[0][1]);\\n              stream.point(t[1][0], t[1][1]);\\n              stream.lineEnd();\\n            } else {\\n              stream.point(t[1][0], t[1][1]);\\n              stream.lineEnd();\\n              stream.lineStart();\\n              stream.point(t[0][0], t[0][1], 3);\\n            }\\n          }\\n        }\\n\\n        if (v && (!point0 || !(0, _pointEqual.default)(point0, point1))) {\\n          stream.point(point1[0], point1[1]);\\n        }\\n\\n        point0 = point1, v0 = v, c0 = c;\\n      },\\n      lineEnd: function () {\\n        if (v0) stream.lineEnd();\\n        point0 = null;\\n      },\\n      // Rejoin first and last segments if there were intersections and the first\\n      // and last points were visible.\\n      clean: function () {\\n        return clean | (v00 && v0) << 1;\\n      }\\n    };\\n  } // Intersects the great circle between a and b with the clip circle.\\n\\n\\n  function intersect(a, b, two) {\\n    var pa = (0, _cartesian.cartesian)(a),\\n        pb = (0, _cartesian.cartesian)(b); // We have two planes, n1.p = d1 and n2.p = d2.\\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 \\u2a2f n2).\\n\\n    var n1 = [1, 0, 0],\\n        // normal\\n    n2 = (0, _cartesian.cartesianCross)(pa, pb),\\n        n2n2 = (0, _cartesian.cartesianDot)(n2, n2),\\n        n1n2 = n2[0],\\n        // cartesianDot(n1, n2),\\n    determinant = n2n2 - n1n2 * n1n2; // Two polar points.\\n\\n    if (!determinant) return !two && a;\\n    var c1 = cr * n2n2 / determinant,\\n        c2 = -cr * n1n2 / determinant,\\n        n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),\\n        A = (0, _cartesian.cartesianScale)(n1, c1),\\n        B = (0, _cartesian.cartesianScale)(n2, c2);\\n    (0, _cartesian.cartesianAddInPlace)(A, B); // Solve |p(t)|^2 = 1.\\n\\n    var u = n1xn2,\\n        w = (0, _cartesian.cartesianDot)(A, u),\\n        uu = (0, _cartesian.cartesianDot)(u, u),\\n        t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1);\\n    if (t2 < 0) return;\\n    var t = (0, _math.sqrt)(t2),\\n        q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);\\n    (0, _cartesian.cartesianAddInPlace)(q, A);\\n    q = (0, _cartesian.spherical)(q);\\n    if (!two) return q; // Two intersection points.\\n\\n    var lambda0 = a[0],\\n        lambda1 = b[0],\\n        phi0 = a[1],\\n        phi1 = b[1],\\n        z;\\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\\n\\n    var delta = lambda1 - lambda0,\\n        polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,\\n        meridian = polar || delta < _math.epsilon;\\n\\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.\\n\\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\\n      var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);\\n      (0, _cartesian.cartesianAddInPlace)(q1, A);\\n      return [q, (0, _cartesian.spherical)(q1)];\\n    }\\n  } // Generates a 4-bit vector representing the location of a point relative to\\n  // the small circle's bounding box.\\n\\n\\n  function code(lambda, phi) {\\n    var r = smallRadius ? radius : _math.pi - radius,\\n        code = 0;\\n    if (lambda < -r) code |= 1; // left\\n    else if (lambda > r) code |= 2; // right\\n\\n    if (phi < -r) code |= 4; // below\\n    else if (phi > r) code |= 8; // above\\n\\n    return code;\\n  }\\n\\n  return (0, _index.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi]);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"Object\",\"defineProperty\",\"value\",\"_default\",\"radius\",\"visible\",\"lambda\",\"phi\",\"_math\",\"cos\",\"cr\",\"intersect\",\"a\",\"b\",\"two\",\"pa\",\"_cartesian\",\"cartesian\",\"pb\",\"n1\",\"n2\",\"cartesianCross\",\"n2n2\",\"cartesianDot\",\"n1n2\",\"determinant\",\"c1\",\"c2\",\"n1xn2\",\"A\",\"cartesianScale\",\"B\",\"cartesianAddInPlace\",\"w\",\"uu\",\"t2\",\"t\",\"sqrt\",\"q\",\"spherical\",\"lambda0\",\"lambda1\",\"phi0\",\"phi1\",\"z\",\"delta\",\"polar\",\"abs\",\"pi\",\"epsilon\",\"meridian\",\"q1\",\"code\",\"r\",\"smallRadius\",\"radians\",\"notHemisphere\",\"_index\",\"clipLine\",\"stream\",\"point0\",\"c0\",\"v0\",\"v00\",\"clean\",\"lineStart\",\"point\",\"point1\",\"v\",\"c\",\"point2\",\"_pointEqual\",\"lineEnd\",\"interpolate\",\"from\",\"to\",\"direction\",\"_circle\",\"circleStream\"]\n}\n"]