["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/d3-geo/src/bounds.js"],"~:js","shadow$provide.module$node_modules$d3_geo$src$bounds=function(global,require,module,exports){function boundsPoint(lambda,phi){ranges.push(range$jscomp$0=[lambda0$jscomp$0=lambda,lambda1=lambda]);phi<phi0&&(phi0=phi);phi>phi1&&(phi1=phi)}function linePoint(lambda,phi){var p=(0,_cartesian.cartesian)([lambda*_math.radians,phi*_math.radians]);if(p0){var normal=(0,_cartesian.cartesianCross)(p0,p);normal=(0,_cartesian.cartesianCross)([normal[1],-normal[0],0],normal);(0,_cartesian.cartesianNormalizeInPlace)(normal);\nnormal=(0,_cartesian.spherical)(normal);var delta=lambda-lambda2,sign=0<delta?1:-1,lambdai=normal[0]*_math.degrees*sign;delta=180<(0,_math.abs)(delta);delta^(sign*lambda2<lambdai&&lambdai<sign*lambda)?(normal=normal[1]*_math.degrees,normal>phi1&&(phi1=normal)):(lambdai=(lambdai+360)%360-180,delta^(sign*lambda2<lambdai&&lambdai<sign*lambda))?(normal=-normal[1]*_math.degrees,normal<phi0&&(phi0=normal)):(phi<phi0&&(phi0=phi),phi>phi1&&(phi1=phi));delta?lambda<lambda2?angle(lambda0$jscomp$0,lambda)>angle(lambda0$jscomp$0,\nlambda1)&&(lambda1=lambda):angle(lambda,lambda1)>angle(lambda0$jscomp$0,lambda1)&&(lambda0$jscomp$0=lambda):lambda1>=lambda0$jscomp$0?(lambda<lambda0$jscomp$0&&(lambda0$jscomp$0=lambda),lambda>lambda1&&(lambda1=lambda)):lambda>lambda2?angle(lambda0$jscomp$0,lambda)>angle(lambda0$jscomp$0,lambda1)&&(lambda1=lambda):angle(lambda,lambda1)>angle(lambda0$jscomp$0,lambda1)&&(lambda0$jscomp$0=lambda)}else ranges.push(range$jscomp$0=[lambda0$jscomp$0=lambda,lambda1=lambda]);phi<phi0&&(phi0=phi);phi>phi1&&\n(phi1=phi);p0=p;lambda2=lambda}function boundsLineStart(){boundsStream.point=linePoint}function boundsLineEnd(){range$jscomp$0[0]=lambda0$jscomp$0;range$jscomp$0[1]=lambda1;boundsStream.point=boundsPoint;p0=null}function boundsRingPoint(lambda,phi){if(p0){var delta=lambda-lambda2;deltaSum.add(180<(0,_math.abs)(delta)?delta+(0<delta?360:-360):delta)}else lambda00=lambda,phi00=phi;_area.areaStream.point(lambda,phi);linePoint(lambda,phi)}function boundsRingStart(){_area.areaStream.lineStart()}function boundsRingEnd(){boundsRingPoint(lambda00,\nphi00);_area.areaStream.lineEnd();(0,_math.abs)(deltaSum)>_math.epsilon&&(lambda0$jscomp$0=-(lambda1=180));range$jscomp$0[0]=lambda0$jscomp$0;range$jscomp$0[1]=lambda1;p0=null}function angle(lambda0,lambda1){return 0>(lambda1-=lambda0)?lambda1+360:lambda1}function rangeCompare(a,b){return a[0]-b[0]}function rangeContains(range,x){return range[0]<=range[1]?range[0]<=x&&x<=range[1]:x<range[0]||range[1]<x}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=function(feature){var n,\nmerged,delta;phi1=lambda1=-(lambda0$jscomp$0=phi0=Infinity);ranges=[];(0,_stream.default)(feature,boundsStream);if(n=ranges.length){ranges.sort(rangeCompare);feature=1;var a=ranges[0];for(merged=[a];feature<n;++feature){var b=ranges[feature];rangeContains(a,b[0])||rangeContains(a,b[1])?(angle(a[0],b[1])>angle(a[0],a[1])&&(a[1]=b[1]),angle(b[0],a[1])>angle(a[0],a[1])&&(a[0]=b[0])):merged.push(a=b)}var deltaMax=-Infinity;n=merged.length-1;feature=0;for(a=merged[n];feature<=n;a=b,++feature)b=merged[feature],\n(delta=angle(a[1],b[0]))>deltaMax&&(deltaMax=delta,lambda0$jscomp$0=b[0],lambda1=a[1])}ranges=range$jscomp$0=null;return Infinity===lambda0$jscomp$0||Infinity===phi0?[[NaN,NaN],[NaN,NaN]]:[[lambda0$jscomp$0,phi0],[lambda1,phi1]]};var _d3Array=require(\"module$node_modules$d3_array$src$index\"),_area=require(\"module$node_modules$d3_geo$src$area\"),_cartesian=require(\"module$node_modules$d3_geo$src$cartesian\"),_math=require(\"module$node_modules$d3_geo$src$math\"),_stream=function(obj){return obj&&obj.__esModule?\nobj:{default:obj}}(require(\"module$node_modules$d3_geo$src$stream\")),lambda0$jscomp$0,phi0,lambda1,phi1,lambda2,lambda00,phi00,p0,deltaSum,ranges,range$jscomp$0,boundsStream={point:boundsPoint,lineStart:boundsLineStart,lineEnd:boundsLineEnd,polygonStart:function(){boundsStream.point=boundsRingPoint;boundsStream.lineStart=boundsRingStart;boundsStream.lineEnd=boundsRingEnd;deltaSum=new _d3Array.Adder;_area.areaStream.polygonStart()},polygonEnd:function(){_area.areaStream.polygonEnd();boundsStream.point=\nboundsPoint;boundsStream.lineStart=boundsLineStart;boundsStream.lineEnd=boundsLineEnd;0>_area.areaRingSum?(lambda0$jscomp$0=-(lambda1=180),phi0=-(phi1=90)):deltaSum>_math.epsilon?phi1=90:deltaSum<-_math.epsilon&&(phi0=-90);range$jscomp$0[0]=lambda0$jscomp$0;range$jscomp$0[1]=lambda1},sphere:function(){lambda0$jscomp$0=-(lambda1=180);phi0=-(phi1=90)}}}","~:source","shadow$provide[\"module$node_modules$d3_geo$src$bounds\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _d3Array = require(\"d3-array\");\n\nvar _area = require(\"./area.js\");\n\nvar _cartesian = require(\"./cartesian.js\");\n\nvar _math = require(\"./math.js\");\n\nvar _stream = _interopRequireDefault(require(\"./stream.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar lambda0, phi0, lambda1, phi1, // bounds\nlambda2, // previous lambda-coordinate\nlambda00, phi00, // first point\np0, // previous 3D point\ndeltaSum, ranges, range;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function () {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new _d3Array.Adder();\n\n    _area.areaStream.polygonStart();\n  },\n  polygonEnd: function () {\n    _area.areaStream.polygonEnd();\n\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math.epsilon) phi1 = 90;else if (deltaSum < -_math.epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function () {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians]);\n\n  if (p0) {\n    var normal = (0, _cartesian.cartesianCross)(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = (0, _cartesian.cartesianCross)(equatorial, normal);\n    (0, _cartesian.cartesianNormalizeInPlace)(inflection);\n    inflection = (0, _cartesian.spherical)(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * _math.degrees * sign,\n        phii,\n        antimeridian = (0, _math.abs)(delta) > 180;\n\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * _math.degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * _math.degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n\n  _area.areaStream.point(lambda, phi);\n\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  _area.areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n\n  _area.areaStream.lineEnd();\n\n  if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n} // Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\n\n\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nfunction _default(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  (0, _stream.default)(feature, boundsStream); // First, sort ranges by their minimum longitudes.\n\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.\n\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    } // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n\n\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$d3_geo$src$math","~$module$node_modules$d3_geo$src$stream","~$shadow.js","~$module$node_modules$d3_geo$src$area","~$module$node_modules$d3_geo$src$cartesian","~$module$node_modules$d3_array$src$index"]],"~:properties",["^5",["polygonStart","__esModule","value","lineEnd","lineStart","polygonEnd","sphere","default","point"]],"~:compiled-at",1653857611299,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$d3_geo$src$bounds.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/d3-geo/src/bounds.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$d3_geo$src$bounds\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = _default;\\n\\nvar _d3Array = require(\\\"d3-array\\\");\\n\\nvar _area = require(\\\"./area.js\\\");\\n\\nvar _cartesian = require(\\\"./cartesian.js\\\");\\n\\nvar _math = require(\\\"./math.js\\\");\\n\\nvar _stream = _interopRequireDefault(require(\\\"./stream.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar lambda0, phi0, lambda1, phi1, // bounds\\nlambda2, // previous lambda-coordinate\\nlambda00, phi00, // first point\\np0, // previous 3D point\\ndeltaSum, ranges, range;\\nvar boundsStream = {\\n  point: boundsPoint,\\n  lineStart: boundsLineStart,\\n  lineEnd: boundsLineEnd,\\n  polygonStart: function () {\\n    boundsStream.point = boundsRingPoint;\\n    boundsStream.lineStart = boundsRingStart;\\n    boundsStream.lineEnd = boundsRingEnd;\\n    deltaSum = new _d3Array.Adder();\\n\\n    _area.areaStream.polygonStart();\\n  },\\n  polygonEnd: function () {\\n    _area.areaStream.polygonEnd();\\n\\n    boundsStream.point = boundsPoint;\\n    boundsStream.lineStart = boundsLineStart;\\n    boundsStream.lineEnd = boundsLineEnd;\\n    if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math.epsilon) phi1 = 90;else if (deltaSum < -_math.epsilon) phi0 = -90;\\n    range[0] = lambda0, range[1] = lambda1;\\n  },\\n  sphere: function () {\\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\\n  }\\n};\\n\\nfunction boundsPoint(lambda, phi) {\\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\\n  if (phi < phi0) phi0 = phi;\\n  if (phi > phi1) phi1 = phi;\\n}\\n\\nfunction linePoint(lambda, phi) {\\n  var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians]);\\n\\n  if (p0) {\\n    var normal = (0, _cartesian.cartesianCross)(p0, p),\\n        equatorial = [normal[1], -normal[0], 0],\\n        inflection = (0, _cartesian.cartesianCross)(equatorial, normal);\\n    (0, _cartesian.cartesianNormalizeInPlace)(inflection);\\n    inflection = (0, _cartesian.spherical)(inflection);\\n    var delta = lambda - lambda2,\\n        sign = delta > 0 ? 1 : -1,\\n        lambdai = inflection[0] * _math.degrees * sign,\\n        phii,\\n        antimeridian = (0, _math.abs)(delta) > 180;\\n\\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\\n      phii = inflection[1] * _math.degrees;\\n      if (phii > phi1) phi1 = phii;\\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\\n      phii = -inflection[1] * _math.degrees;\\n      if (phii < phi0) phi0 = phii;\\n    } else {\\n      if (phi < phi0) phi0 = phi;\\n      if (phi > phi1) phi1 = phi;\\n    }\\n\\n    if (antimeridian) {\\n      if (lambda < lambda2) {\\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\\n      } else {\\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\\n      }\\n    } else {\\n      if (lambda1 >= lambda0) {\\n        if (lambda < lambda0) lambda0 = lambda;\\n        if (lambda > lambda1) lambda1 = lambda;\\n      } else {\\n        if (lambda > lambda2) {\\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\\n        } else {\\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\\n        }\\n      }\\n    }\\n  } else {\\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\\n  }\\n\\n  if (phi < phi0) phi0 = phi;\\n  if (phi > phi1) phi1 = phi;\\n  p0 = p, lambda2 = lambda;\\n}\\n\\nfunction boundsLineStart() {\\n  boundsStream.point = linePoint;\\n}\\n\\nfunction boundsLineEnd() {\\n  range[0] = lambda0, range[1] = lambda1;\\n  boundsStream.point = boundsPoint;\\n  p0 = null;\\n}\\n\\nfunction boundsRingPoint(lambda, phi) {\\n  if (p0) {\\n    var delta = lambda - lambda2;\\n    deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\\n  } else {\\n    lambda00 = lambda, phi00 = phi;\\n  }\\n\\n  _area.areaStream.point(lambda, phi);\\n\\n  linePoint(lambda, phi);\\n}\\n\\nfunction boundsRingStart() {\\n  _area.areaStream.lineStart();\\n}\\n\\nfunction boundsRingEnd() {\\n  boundsRingPoint(lambda00, phi00);\\n\\n  _area.areaStream.lineEnd();\\n\\n  if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180);\\n  range[0] = lambda0, range[1] = lambda1;\\n  p0 = null;\\n} // Finds the left-right distance between two longitudes.\\n// This is almost the same as (lambda1 - lambda0 + 360\\u00b0) % 360\\u00b0, except that we want\\n// the distance between \\u00b1180\\u00b0 to be 360\\u00b0.\\n\\n\\nfunction angle(lambda0, lambda1) {\\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\\n}\\n\\nfunction rangeCompare(a, b) {\\n  return a[0] - b[0];\\n}\\n\\nfunction rangeContains(range, x) {\\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\\n}\\n\\nfunction _default(feature) {\\n  var i, n, a, b, merged, deltaMax, delta;\\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\\n  ranges = [];\\n  (0, _stream.default)(feature, boundsStream); // First, sort ranges by their minimum longitudes.\\n\\n  if (n = ranges.length) {\\n    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.\\n\\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\\n      b = ranges[i];\\n\\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\\n      } else {\\n        merged.push(a = b);\\n      }\\n    } // Finally, find the largest gap between the merged ranges.\\n    // The final bounding box will be the inverse of this gap.\\n\\n\\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\\n      b = merged[i];\\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\\n    }\\n  }\\n\\n  ranges = range = null;\\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"boundsPoint\",\"lambda\",\"phi\",\"ranges\",\"push\",\"range\",\"lambda0\",\"lambda1\",\"phi0\",\"phi1\",\"linePoint\",\"p\",\"_cartesian\",\"cartesian\",\"_math\",\"radians\",\"p0\",\"normal\",\"cartesianCross\",\"inflection\",\"equatorial\",\"cartesianNormalizeInPlace\",\"spherical\",\"delta\",\"lambda2\",\"sign\",\"lambdai\",\"degrees\",\"antimeridian\",\"abs\",\"phii\",\"angle\",\"boundsLineStart\",\"boundsStream\",\"point\",\"boundsLineEnd\",\"boundsRingPoint\",\"deltaSum\",\"add\",\"lambda00\",\"phi00\",\"_area\",\"areaStream\",\"boundsRingStart\",\"lineStart\",\"boundsRingEnd\",\"lineEnd\",\"epsilon\",\"rangeCompare\",\"a\",\"b\",\"rangeContains\",\"x\",\"Object\",\"defineProperty\",\"value\",\"default\",\"_default\",\"feature\",\"n\",\"merged\",\"Infinity\",\"_stream\",\"length\",\"sort\",\"i\",\"deltaMax\",\"NaN\",\"_d3Array\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"polygonStart\",\"Adder\",\"polygonEnd\",\"areaRingSum\",\"sphere\"]\n}\n"]